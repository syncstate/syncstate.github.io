<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Core Concepts · SyncState</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="What do we mean when we say SyncState is a document-based state management library?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Core Concepts · SyncState"/><meta property="og:type" content="website"/><meta property="og:url" content="https://syncstate.github.io/"/><meta property="og:description" content="What do we mean when we say SyncState is a document-based state management library?"/><meta property="og:image" content="https://syncstate.github.io/img/SyncStateLogoWithBackground.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://syncstate.github.io/img/SyncStateLogoWithBackground.png"/><link rel="shortcut icon" href="/img/SyncStateLogoWithBackground.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7BDM43KW3G"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-7BDM43KW3G');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/SyncStateLogoWhite.svg" alt="SyncState"/><h2 class="headerTitleWithLogo">SyncState</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/getting-started" target="_self">Docs</a></li><li class="siteNavGroupActive"><a href="/docs/faq" target="_self">FAQ</a></li><li class=""><a href="https://github.com/syncstate/core" target="_self">Github</a></li><li class=""><a href="https://geekyants.com/hire?utm_source=syncstate&amp;utm_medium=header&amp;utm_campaign=syncstate" target="_self">Hire The Creators</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Introduction</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/getting-started">Getting started</a></li><li class="navListItem"><a class="navItem" href="/docs/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/motivation">Motivation</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/core-concepts">Core Concepts</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Recipes</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/recipes">Recipes</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Examples</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/counter-example">Counter</a></li><li class="navListItem"><a class="navItem" href="/docs/counter-with-redo-undo-example">Counter with Undo / Redo</a></li><li class="navListItem"><a class="navItem" href="/docs/todo-app-example">Todo app</a></li><li class="navListItem"><a class="navItem" href="/docs/multi-user-counter-example">Multi User Counter</a></li><li class="navListItem"><a class="navItem" href="/docs/multi-user-todo-example">Multi User Todo</a></li><li class="navListItem"><a class="navItem" href="/docs/multi-user-todo-example-with-undo-redo">Multi User Todo With Undo/Redo</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Plugins</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/history-plugin">History</a></li><li class="navListItem"><a class="navItem" href="/docs/remote-plugin">Remote</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/api-ref">API Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/create-doc">createDocStore</a></li><li class="navListItem"><a class="navItem" href="/docs/store">Store</a></li><li class="navListItem"><a class="navItem" href="/docs/provider">Provider</a></li><li class="navListItem"><a class="navItem" href="/docs/use-doc">useDoc</a></li><li class="navListItem"><a class="navItem" href="/docs/use-syncstate">useSyncState</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tips &amp; Tricks</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/common-pitfalls">Common Pitfalls &amp; Best Practices</a></li><li class="navListItem"><a class="navItem" href="/docs/noreact">Using SyncState without React</a></li><li class="navListItem"><a class="navItem" href="/docs/performance-tuning">Performance Tuning</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">FAQ</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ&#x27;s</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Core Concepts</h1></header><article><div><span><p>What do we mean when we say SyncState is a document-based state management library?</p>
<p>Let's consider that your app state is represented by this JSON document below.</p>
<pre><code class="hljs css language-jsx">{
    <span class="hljs-attr">todos</span>: [
        {
            <span class="hljs-attr">caption</span>: <span class="hljs-string">"Hello"</span>,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
    ],
    <span class="hljs-attr">filter</span>: <span class="hljs-string">"all"</span>
}
</code></pre>
<p>We can use a <a href="https://tools.ietf.org/html/rfc6902">JSON patch</a> to modify this document.</p>
<pre><code class="hljs css language-jsx">{
  <span class="hljs-attr">op</span>: <span class="hljs-string">"add"</span>,
    <span class="hljs-attr">path</span>: <span class="hljs-string">"/todos/1"</span>,
    <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">caption</span>: <span class="hljs-string">"Hi!"</span>,
        <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
    }
}
</code></pre>
<p>Document after applying the JSON Patch:</p>
<pre><code class="hljs css language-jsx">{
    <span class="hljs-attr">todos</span>: [
        {
            <span class="hljs-attr">caption</span>: <span class="hljs-string">"Hello"</span>,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        },
        {
            <span class="hljs-attr">caption</span>: <span class="hljs-string">"Hi!"</span>,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
    ],
    <span class="hljs-attr">filter</span>: <span class="hljs-string">"all"</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="applying-a-series-of-patches"></a><a href="#applying-a-series-of-patches" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applying a series of patches</h2>
<p>We can apply a series of patches to successive documents. The following example starts with a document with empty <code>todos</code>, applies a patch to add a todo item and then replaces the caption of the todo item from <code>&quot;Hello&quot;</code> to <code>&quot;Hi&quot;</code>.</p>
<p><img src="/img/Storing_Document_vs_JSON_Patches.png" alt="Storing_Document_vs_JSON_Patches.png"></p>
<h2><a class="anchor" aria-hidden="true" id="how-to-build-it"></a><a href="#how-to-build-it" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to build it?</h2>
<p>Let's say we have a function that updates the document with JSON patches <code>applyPatches(doc, patches)</code></p>
<p>Now, instead of mutating the document, we can replace this by a new document following the concepts of functional programming. <code>applyPatches(doc, patches)</code> can return the new document.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">const</span> newDoc = applyPatches(doc, patches);
</code></pre>
<p>Let's describe the patch as a Redux action</p>
<pre><code class="hljs css language-jsx">{
    <span class="hljs-attr">type</span>: <span class="hljs-string">"PATCHES"</span>,
    <span class="hljs-attr">payload</span>: [{
      <span class="hljs-attr">op</span>: <span class="hljs-string">"add"</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">"/todos/1"</span>,
        <span class="hljs-attr">value</span>: {
            <span class="hljs-attr">caption</span>: <span class="hljs-string">"Hi!"</span>,
            <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
        }
    }]
}
</code></pre>
<p>If we store the document in a Redux store, dispatching this action will replace the document with a new one using a reducer.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">docReducer</span>(<span class="hljs-params">state = {}, action</span>) </span>{
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"PATCH"</span>:
            <span class="hljs-keyword">return</span> applyPatches(state, action.payload);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> state;
    }
}
</code></pre>
<p>SyncState uses the above concept to store the app state as document in its internal Redux store and updates it using JSON patches as actions.</p>
<h2><a class="anchor" aria-hidden="true" id="simplifying-it-further-with-immer"></a><a href="#simplifying-it-further-with-immer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simplifying it further with Immer</h2>
<p>Writing patches for all user actions is cumbersome. So let's use <a href="https://immerjs.github.io/immer/docs/patches">Immer</a> to handle generation and application of patches.</p>
<h3><a class="anchor" aria-hidden="true" id="auto-generating-patches-with-immer"></a><a href="#auto-generating-patches-with-immer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto-generating patches with Immer</h3>
<p>Immer has a function <code>produceWithPatches</code> which lets you perform mutations on a draft state and returns the new state with patches and inversePatches. Applying these patches to the original state will give a state which is identical to the new state returned by <code>produceWithPatches</code>.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">let</span> [newDoc, patches, inversePatches] = produceWithPatches(doc, (draftDoc) =&gt; {
    draftDoc.todos.push(todoItem);
});
</code></pre>
<p>Immer also provides <code>applyPatches</code> function which works the same as described <a href="#how-to-build-it">above</a>.</p>
<blockquote>
<p><strong>Note:</strong> JSON patch patch in Immer here is similar (but not the same) to <a href="https://tools.ietf.org/html/rfc6902">JSON patches RFC 6902</a>. Instead of a string of keys/indexes joined by /, it is an array of keys/indexes.</p>
</blockquote>
<p>Combining the above knowledge, let's see a simplified example for adding a todo.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> { produceWithPatches } <span class="hljs-keyword">from</span> <span class="hljs-string">"immer"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">store, todoItem</span>) </span>{
    <span class="hljs-keyword">const</span> doc = store.getState();

    <span class="hljs-keyword">let</span> [newDoc, patches, inversePatches] = produceWithPatches(
        doc,
        (draftDoc) =&gt; {
            draftDoc.todos.push(todoItem);
        }
    );

    store.dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">"PATCHES"</span>,
        <span class="hljs-attr">payload</span>: patches,
    });
}
</code></pre>
<p>Now, you can simply call <code>addTodo(store, {caption: &quot;Hi!&quot;, completed: false})</code> and a JSON patch will be generated by Immer for the operation <code>draftDoc.todos.push(todoItem)</code> and dispatched to the store.</p>
<p>In the reducer, we can use <code>applyPatches</code> function from Immer.</p>
<pre><code class="hljs css language-jsx">applyPatches(state.document, action.payload);
</code></pre>
<p>This will return the resulting document after applying the patch.</p>
<p>We can generalize this further for any action.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDoc</span>(<span class="hljs-params">store, callback</span>) </span>{
    <span class="hljs-keyword">const</span> doc = store.getState();
    <span class="hljs-keyword">let</span> [newDoc, patches, inversePatches] = produceWithPatches(doc, callback);

    store.dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">"PATCHES"</span>,
        <span class="hljs-attr">payload</span>: patches,
    });
}

<span class="hljs-comment">// Call setDoc function and perform mutations on draft document received in the</span>
<span class="hljs-comment">// callback passed as second argument.</span>
<span class="hljs-comment">// setDoc function will dispatch generated patches for those mutations.</span>
setDoc(store, (draftDoc) =&gt; {
    draftDoc.filter = <span class="hljs-string">"completed"</span>;
    draftDoc.todos.push({ <span class="hljs-attr">caption</span>: <span class="hljs-string">"Say hello!"</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> });
});
</code></pre>
<p>We have simplified this such that any mutation can be done on draft state without worrying about patches, Redux actions or reducers for simple use cases.</p>
<h2><a class="anchor" aria-hidden="true" id="syncing-documents-across-network--threads"></a><a href="#syncing-documents-across-network--threads" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syncing documents (across Network &amp; Threads)</h2>
<p>Applying the same patches to identical documents will produce identical documents.</p>
<p><img src="/img/Applying_the_patch_to_client_server_architecture.png" alt="Applying the patch to client server architecture"></p>
<p>This comes in handy if you are building a multi-user realtime app.</p>
<p>However, with multi-user realtime apps we have a few challenges:</p>
<ul>
<li>Conflict resolution in case of simultaneous modification at same path.</li>
<li>Conflict resolution in case of modification at a path by one client and replacement/deletion of a node at the same path by another client.</li>
<li>Optimistic updates on clients and reversal when needed.</li>
<li>Maintaining undo/redo history on clients with updates received from other clients.</li>
</ul>
<p>While these challenges cannot be handled the same way for every app but we believe that the majority of the use cases are very common and can be provided as a <a href="/docs/history-plugin">plugin of SyncState</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="comparison-with-redux"></a><a href="#comparison-with-redux" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison with Redux</h2>
<ul>
<li>SyncState uses <code>Redux</code> but doesn't use <code>react-redux</code></li>
<li>We store patches (or actions) along with the state in the global store.</li>
</ul>
<pre><code class="hljs css language-tsx">{
    <span class="hljs-attribute">docState</span>: {},
    <span class="hljs-selector-tag">docPatches</span>: <span class="hljs-selector-attr">[]</span>
}
</code></pre>
<ul>
<li>State can be computed by applying a series of patches.</li>
<li>We pass down <code>paths</code> to components instead of a part of the <code>state</code>.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="no-react-redux"></a><a href="#no-react-redux" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>No react-redux</h3>
<p>SyncState doesn't use <code>react-redux</code> and it's <code>connect()</code> method, mainly to achieve higher performance. With <code>react-redux</code>, <code>connect()</code> method is always executed on the mounted components even if the component doesn't need a re-render.</p>
<p><img src="/img/React_Tree__4.png" alt="React_Tree__4"></p>
<p>In this component tree, <code>connect()</code> is called on all the connected components, even though only green one needs to be rerendered.</p>
<p>There are techniques to make the <code>connect()</code> method performant with <code>selection</code> and <code>caching</code> but the underlying philosophy remains the same.</p>
<p>Kent C. Dodds has summarized the strategies of re-render as push and pull.</p>
<p><img src="/img/no-redux.png" alt="No react-redux image"></p>
<p>SyncState uses Redux but the re-renders are based on <strong>push-based state management</strong> like MobX &amp; Recoil.</p>
<p>A component subscribes to a particular path in a SyncState store</p>
<p><img src="/img/SyncState_cycle.png" alt="SyncState"></p>
<pre><code class="hljs css language-jsx"><span class="hljs-comment">// In React component TodoApp.jsx</span>
<span class="hljs-comment">// Fetch todos at path "/todos" and modify it using setTodos.</span>
<span class="hljs-comment">// Component subscribes to changes at "/todos" path.</span>
<span class="hljs-keyword">const</span> [todos, setTodos] = useDoc(<span class="hljs-string">"/todos"</span>);
</code></pre>
<p>The component is rerendered whenever there are updates to the path that it subscribes to.</p>
<p><img src="/img/SyncStatePath.png" alt="SyncStatePath"></p>
<p>Components can pass down path as props to child components to subscribe to.</p>
<pre><code class="hljs css language-jsx"><span class="hljs-comment">// In React component TodoApp.jsx</span>
<span class="hljs-keyword">const</span> todoPath = <span class="hljs-string">"/todos"</span>;
<span class="hljs-keyword">const</span> [todos, setTodos] = useDoc(todoPath);

<span class="hljs-keyword">return</span> todos.map(<span class="hljs-function">(<span class="hljs-params">todoItem, index</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">path</span>=<span class="hljs-string">{todoPath</span> + "/" + <span class="hljs-attr">index</span>} /&gt;</span></span>
));

<span class="hljs-comment">// In React component TodoItem.jsx</span>
<span class="hljs-comment">// Fetch todoItem at path received as a prop =&gt; "/todos/&lt;index&gt;"</span>
<span class="hljs-comment">// and modify it using setTodoItem.</span>
<span class="hljs-comment">// Component subscribes to changes at "/todos/&lt;index&gt;" path.</span>
<span class="hljs-keyword">const</span> [todoItem, setTodoItem] = useDoc(props.path);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="comparison-with-recoil"></a><a href="#comparison-with-recoil" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison with Recoil</h2>
<ul>
<li>Recoil has atoms which are units of state. They are not part of a single state tree or document like in SyncState.</li>
<li>SyncState uses the performant re-renders, much like Recoil. Recoil re-renders a component when the atom it subscribes to is updated whereas SyncState re-renders a component when the state at the path it subscribes to is updated in the document.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="comparison-with-mobx--mst"></a><a href="#comparison-with-mobx--mst" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison with MobX &amp; MST</h2>
<ul>
<li>SyncState uses event listeners for performant re-renders like MobX. MobX uses observable value, SyncState uses document paths.</li>
<li>SyncState works with immutable states unlike MobX. However, SyncState allows mutations which happen on a draft state using Immer while maintaining immutability internally.</li>
<li>With MobX, we generally follow Object Oriented programming concepts while SyncState isn't purely Object Oriented. We don't add methods to our data models. And since all the mutations are via patches, we don't need to worry if we are mutating or not mutating the original object. The re-renders are based on events that carry the path at which the data was changed.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<ul>
<li>SyncState is based on Redux &amp; Immer. It uses JSON patches for actions.</li>
<li>Also, it doesn't use <code>connect()</code> to connect state to React components, it's based on events (actions) for greater performance. It uses a <code>useDoc()</code> hook that listens to the updates on the <code>path</code> (<a href="https://twitter.com/kentcdodds/status/1180157212485771264">push strategy</a>) that the component is listening to and forces an update. (like Recoil).</li>
<li>We don't pass down states to components but use paths instead. It works like an ID that can be used to re-render the components. It also helps in not maintaining <code>indexes</code> on lists with actions like Redux.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/motivation"><span class="arrow-prev">← </span><span>Motivation</span></a><a class="docs-next button" href="/docs/recipes"><span>Recipes</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#applying-a-series-of-patches">Applying a series of patches</a></li><li><a href="#how-to-build-it">How to build it?</a></li><li><a href="#simplifying-it-further-with-immer">Simplifying it further with Immer</a><ul class="toc-headings"><li><a href="#auto-generating-patches-with-immer">Auto-generating patches with Immer</a></li></ul></li><li><a href="#syncing-documents-across-network--threads">Syncing documents (across Network &amp; Threads)</a></li><li><a href="#comparison-with-redux">Comparison with Redux</a><ul class="toc-headings"><li><a href="#no-react-redux">No react-redux</a></li></ul></li><li><a href="#comparison-with-recoil">Comparison with Recoil</a></li><li><a href="#comparison-with-mobx--mst">Comparison with MobX &amp; MST</a></li><li><a href="#summary">Summary</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div><h5>Docs</h5><a href="/docs/getting-started">Getting Started</a><a href="/docs/counter-example">Examples</a><a href="/docs/history-plugin">Plugins</a><a href="/docs/api-ref">API Reference</a><a href="/docs/faq">FAQ</a></div><div><h5>Community</h5><a href="https://twitter.com/SyncstateIO" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://stackoverflow.com/questions/tagged/syncstate" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discord.com/invite/FnET5S9" target="_blank" rel="noreferrer noopener">Discord</a></div><div><h5>More</h5><a target="_blank" href="https://github.com/syncstate/core" rel="noreferrer noopener">GitHub   </a><a target="_blank" href="https://github.com/syncstate/core/blob/master/CONTRIBUTING.md" rel="noreferrer noopener">Contribution Guidelines</a><br/><a class="github-button" href="https://github.com/syncstate/core" data-icon="octicon-star" data-count-href="https://github.com/syncstate/core" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Stars</a></div><div><a href="https://geekyants.com/?utm_source=syncstate&amp;utm_medium=footer&amp;utm_campaign=syncstate" target="_blank" rel="noreferrer noopener">Built with ❤️ at GeekyAnts.</a></div></section><section class="copyright" style="margin-bottom:20px"></section><section class="copyright">Copyright © 2020 SyncState</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '811af76a47f6b4a94d8880d4fbddf3b8',
                indexName: 'syncstate',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:en"]}
              });
            </script></body></html>